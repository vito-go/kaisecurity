package dao

import (
	"context"
	"github.com/vito-go/kaisecurity/internal/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

type vulnerability struct {
	Gdb *gorm.DB
}

func (s *vulnerability) Table() string {
	return "vulnerability"
}

// CreateBatch .
func (s *vulnerability) CreateBatch(ctx context.Context, items ...model.Vulnerability) error {
	if len(items) == 0 {
		return nil
	}
	return s.Gdb.WithContext(ctx).Table(s.Table()).Clauses(clause.Insert{
		Modifier: "OR IGNORE",
	}).Create(items).Error
}

func (s *vulnerability) ItemBySeverity(ctx context.Context, severity string) (*model.Vulnerability, error) {
	var msg model.Vulnerability
	tx := s.Gdb.WithContext(ctx).Table(s.Table()).Where("severity = ?", severity).Order("update_time desc").First(&msg)
	if tx.RowsAffected == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	return &msg, tx.Error
}

func (s *vulnerability) UpdateOrCreate(ctx context.Context, m *model.Vulnerability) (err error) {
	TX := s.Gdb.WithContext(ctx).Table(s.Table()).Begin()
	defer func() {
		if err != nil {
			TX.Rollback()
			return
		}
		err = TX.Commit().Error
	}()
	tx := TX.Where("scan_id = ? AND id=?", m.ScanId, m.Id).Updates(m)
	if tx.Error != nil {
		return tx.Error
	}
	if tx.RowsAffected == 0 {
		if err = tx.Create(m).Error; err != nil {
			return err
		}
		return nil
	}
	return nil
}
